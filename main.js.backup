// Eterus - Main JavaScript File
// Advanced animations and interactions for premium tech agency website

// Splash Screen Controller
class SplashScreen {
    constructor() {
        this.splashScreen = document.getElementById('splashScreen');
        this.loaderPercentage = document.getElementById('loaderPercentage');
        this.hasVisited = sessionStorage.getItem('eterusVisited');

        this.init();
    }

    init() {
        // Skip splash if user already visited in this session
        if (this.hasVisited) {
            this.splashScreen.classList.add('hidden');
            return;
        }

        // Animate loading percentage
        let progress = 0;
        const interval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress >= 100) {
                progress = 100;
                clearInterval(interval);
                this.hideSplash();
            }
            this.loaderPercentage.textContent = Math.floor(progress) + '%';
        }, 100);
    }

    hideSplash() {
        setTimeout(() => {
            this.splashScreen.classList.add('hidden');
            sessionStorage.setItem('eterusVisited', 'true');

            // Remove from DOM after transition
            setTimeout(() => {
                this.splashScreen.remove();
            }, 800);
        }, 500);
    }
}

// Scroll Progress Bar
class ScrollProgressBar {
    constructor() {
        this.progressBar = document.getElementById('scrollProgress');
        this.init();
    }

    init() {
        window.addEventListener('scroll', () => this.updateProgress());
        this.updateProgress(); // Initial update
    }

    updateProgress() {
        const windowHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrolled = (window.scrollY / windowHeight) * 100;
        this.progressBar.style.width = scrolled + '%';
    }
}

// Advanced Custom Cursor
class AdvancedCursor {
    constructor() {
        this.cursor = document.getElementById('customCursor');
        this.follower = document.getElementById('cursorFollower');
        this.cursorText = document.getElementById('cursorText');

        this.cursorPos = { x: 0, y: 0 };
        this.followerPos = { x: 0, y: 0 };

        this.init();
    }

    init() {
        if (!this.cursor || !this.follower) return;

        // Track mouse movement
        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));

        // Hide cursor when leaving window
        document.addEventListener('mouseleave', () => this.hideCursor());
        document.addEventListener('mouseenter', () => this.showCursor());

        // Detect interactive elements
        const interactiveElements = document.querySelectorAll('a, button, input, textarea, select, .service-card');
        interactiveElements.forEach(el => {
            el.addEventListener('mouseenter', () => this.expandCursor(el));
            el.addEventListener('mouseleave', () => this.contractCursor());
        });

        // Start animation loop
        this.animate();
    }

    handleMouseMove(e) {
        this.cursorPos.x = e.clientX;
        this.cursorPos.y = e.clientY;

        // Update cursor text position immediately
        this.cursorText.style.left = e.clientX + 'px';
        this.cursorText.style.top = e.clientY + 'px';
    }

    expandCursor(element) {
        this.cursor.classList.add('expand');
        this.follower.classList.add('expand');

        // Show text label for specific elements
        const label = element.getAttribute('data-cursor-text') ||
                     element.getAttribute('aria-label') ||
                     (element.tagName === 'A' ? 'Clicar' : '');

        if (label) {
            this.cursorText.textContent = label;
            this.cursorText.classList.add('visible');
        }
    }

    contractCursor() {
        this.cursor.classList.remove('expand');
        this.follower.classList.remove('expand');
        this.cursorText.classList.remove('visible');
    }

    hideCursor() {
        this.cursor.classList.add('hidden');
        this.follower.classList.add('hidden');
        this.cursorText.classList.remove('visible');
    }

    showCursor() {
        this.cursor.classList.remove('hidden');
        this.follower.classList.remove('hidden');
    }

    animate() {
        // Smooth cursor movement (main cursor is faster)
        this.cursor.style.left = this.cursorPos.x + 'px';
        this.cursor.style.top = this.cursorPos.y + 'px';

        // Smooth follower with delay (lerp interpolation)
        this.followerPos.x += (this.cursorPos.x - this.followerPos.x) * 0.15;
        this.followerPos.y += (this.cursorPos.y - this.followerPos.y) * 0.15;

        this.follower.style.left = (this.followerPos.x - 20) + 'px';
        this.follower.style.top = (this.followerPos.y - 20) + 'px';

        requestAnimationFrame(() => this.animate());
    }
}

// Magnetic Button Effect
class MagneticButtons {
    constructor() {
        this.buttons = document.querySelectorAll('.magnetic-btn');
        this.init();
    }

    init() {
        this.buttons.forEach(button => {
            button.addEventListener('mousemove', (e) => this.handleMouseMove(e, button));
            button.addEventListener('mouseleave', () => this.handleMouseLeave(button));
            button.addEventListener('click', (e) => this.createRipple(e, button));
        });
    }

    handleMouseMove(e, button) {
        const rect = button.getBoundingClientRect();
        const x = e.clientX - rect.left - rect.width / 2;
        const y = e.clientY - rect.top - rect.height / 2;

        // Magnetic effect - button follows cursor within 100px radius
        const distance = Math.sqrt(x * x + y * y);
        const maxDistance = 80;

        if (distance < maxDistance) {
            const strength = (maxDistance - distance) / maxDistance;
            const moveX = x * strength * 0.4;
            const moveY = y * strength * 0.4;

            button.style.transform = `translate(${moveX}px, ${moveY}px)`;

            // Inner element movement (parallax effect)
            const inner = button.querySelector('.magnetic-btn-inner');
            if (inner) {
                inner.style.transform = `translate(${moveX * 0.5}px, ${moveY * 0.5}px)`;
            }
        }
    }

    handleMouseLeave(button) {
        button.style.transform = 'translate(0, 0)';
        const inner = button.querySelector('.magnetic-btn-inner');
        if (inner) {
            inner.style.transform = 'translate(0, 0)';
        }
    }

    createRipple(e, button) {
        const ripple = document.createElement('span');
        ripple.className = 'ripple';

        const rect = button.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = e.clientX - rect.left - size / 2;
        const y = e.clientY - rect.top - size / 2;

        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = x + 'px';
        ripple.style.top = y + 'px';

        button.appendChild(ripple);

        // Remove ripple after animation
        setTimeout(() => {
            ripple.remove();
        }, 600);
    }
}

class EterusAnimations {
    constructor() {
        this.heroCanvas = null;
        this.particles = [];
        this.mouse = { x: 0, y: 0 };
        this.scrollY = 0;
        this.cursorTrail = document.getElementById('cursorTrail');

        this.init();
    }

    init() {
        this.setupCursorTrail();
        this.setupHeroAnimation();
        this.setupScrollAnimations();
        this.setupParticleSystem();
        this.setupAboutAnimation();
        this.setupNavbar();
        this.setupFormHandling();

        // Initialize all animations
        this.animate();
    }
    
    setupCursorTrail() {
        // Cursor is now handled by AdvancedCursor class
        // Just track mouse position for other effects
        document.addEventListener('mousemove', (e) => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
    }
    
    setupHeroAnimation() {
        const canvas = document.getElementById('heroCanvas');
        if (!canvas) return;

        // Initialize Three.js hero scene
        this.initHero3D(canvas);
    }

    initHero3D(canvas) {
        // Scene setup
        this.hero3D = {
            scene: new THREE.Scene(),
            camera: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
            renderer: new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            })
        };

        const { scene, camera, renderer } = this.hero3D;

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);

        // Morphing geometry system - Multiple shapes that transition
        this.hero3D.geometries = [
            new THREE.IcosahedronGeometry(8, 1),      // Shape 1: Diamond
            new THREE.TorusGeometry(8, 2.5, 32, 64),  // Shape 2: Ring
            new THREE.OctahedronGeometry(9, 2),       // Shape 3: Crystal
            new THREE.SphereGeometry(8, 32, 32)       // Shape 4: Sphere
        ];

        this.hero3D.currentShapeIndex = 0;
        this.hero3D.morphProgress = 0;

        // Start with first geometry
        const geometry = this.hero3D.geometries[0].clone();

        // Enhanced material with better visual
        const material = new THREE.MeshBasicMaterial({
            color: 0x0066FF,
            wireframe: true,
            transparent: true,
            opacity: 0.9
        });

        this.hero3D.mainMesh = new THREE.Mesh(geometry, material);
        scene.add(this.hero3D.mainMesh);

        // Solid inner core for depth
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: 0x0066FF,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });
        this.hero3D.coreMesh = new THREE.Mesh(geometry.clone(), coreMaterial);
        this.hero3D.coreMesh.scale.set(0.95, 0.95, 0.95);
        scene.add(this.hero3D.coreMesh);

        // Glow outline layer
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00D4FF,
            wireframe: true,
            transparent: true,
            opacity: 0.4
        });
        this.hero3D.glowMesh = new THREE.Mesh(geometry.clone(), glowMaterial);
        this.hero3D.glowMesh.scale.set(1.05, 1.05, 1.05);
        scene.add(this.hero3D.glowMesh);

        // Particle system around main geometry
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 2000;
        const posArray = new Float32Array(particlesCount * 3);
        const velocityArray = new Float32Array(particlesCount * 3);

        for (let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 100;
            velocityArray[i] = (Math.random() - 0.5) * 0.02;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.1,
            color: 0x0066FF,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        this.hero3D.particles = new THREE.Points(particlesGeometry, particlesMaterial);
        this.hero3D.particleVelocities = velocityArray;
        scene.add(this.hero3D.particles);

        // Orbiting smaller geometries
        this.hero3D.orbitMeshes = [];
        for (let i = 0; i < 5; i++) {
            const orbitGeometry = new THREE.OctahedronGeometry(1.5, 0);
            const orbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x0066FF,
                wireframe: true,
                transparent: true,
                opacity: 0.6
            });
            const orbitMesh = new THREE.Mesh(orbitGeometry, orbitMaterial);

            // Random orbital positions
            const angle = (i / 5) * Math.PI * 2;
            const radius = 20;
            orbitMesh.position.x = Math.cos(angle) * radius;
            orbitMesh.position.z = Math.sin(angle) * radius;
            orbitMesh.userData = { angle, radius, speed: 0.001 + Math.random() * 0.002 };

            this.hero3D.orbitMeshes.push(orbitMesh);
            scene.add(orbitMesh);
        }

        camera.position.z = 40;

        // Mouse interaction variables
        this.hero3D.targetRotationX = 0;
        this.hero3D.targetRotationY = 0;
        this.hero3D.explosionActive = false;
        this.hero3D.explosionParticles = [];

        // Morphing system
        this.hero3D.morphTimer = 0;
        this.hero3D.morphDuration = 300; // frames before morphing
        this.hero3D.isMorphing = false;

        // Click to morph to next shape (and explode)
        canvas.addEventListener('click', () => {
            this.triggerExplosion();
            this.morphToNextShape();
        });

        // Resize handler
        window.addEventListener('resize', () => this.onHero3DResize());

        // Gyroscope for mobile
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ requires permission
            canvas.addEventListener('click', () => {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', (e) => this.handleGyroscope(e));
                        }
                    });
            }, { once: true });
        } else if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => this.handleGyroscope(e));
        }
    }

    onHero3DResize() {
        if (!this.hero3D) return;

        const { camera, renderer } = this.hero3D;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    handleGyroscope(event) {
        if (!this.hero3D) return;

        // Convert device orientation to rotation
        const beta = event.beta || 0; // X axis (-180 to 180)
        const gamma = event.gamma || 0; // Y axis (-90 to 90)

        this.hero3D.targetRotationX = (beta / 180) * Math.PI;
        this.hero3D.targetRotationY = (gamma / 90) * Math.PI;
    }

    morphToNextShape() {
        if (!this.hero3D || this.hero3D.isMorphing) return;

        this.hero3D.isMorphing = true;
        this.hero3D.morphProgress = 0;

        // Get next shape index
        const nextIndex = (this.hero3D.currentShapeIndex + 1) % this.hero3D.geometries.length;

        // Store current and next geometries
        this.hero3D.currentGeometry = this.hero3D.mainMesh.geometry;
        this.hero3D.nextGeometry = this.hero3D.geometries[nextIndex].clone();

        // Update index
        this.hero3D.currentShapeIndex = nextIndex;

        // Morphing animation (will be handled in updateHero3D)
        setTimeout(() => {
            this.hero3D.isMorphing = false;
        }, 2000);
    }

    triggerExplosion() {
        if (!this.hero3D) return;

        this.hero3D.explosionActive = true;
        this.hero3D.explosionParticles = [];

        // Create explosion particles
        const count = 100;
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const velocity = 0.5 + Math.random() * 0.5;

            this.hero3D.explosionParticles.push({
                x: 0,
                y: 0,
                z: 0,
                vx: Math.cos(angle) * velocity,
                vy: (Math.random() - 0.5) * velocity,
                vz: Math.sin(angle) * velocity,
                life: 1.0
            });
        }

        // Reset after animation
        setTimeout(() => {
            this.hero3D.explosionActive = false;
            this.hero3D.explosionParticles = [];
        }, 2000);
    }

    updateHero3D() {
        if (!this.hero3D) return;

        const { scene, camera, renderer, mainMesh, glowMesh, coreMesh, particles, orbitMeshes } = this.hero3D;

        // Handle morphing animation
        if (this.hero3D.isMorphing) {
            this.hero3D.morphProgress += 0.02; // Speed of morph

            if (this.hero3D.morphProgress >= 1) {
                // Morphing complete - swap geometry
                mainMesh.geometry.dispose();
                mainMesh.geometry = this.hero3D.nextGeometry;

                glowMesh.geometry.dispose();
                glowMesh.geometry = this.hero3D.nextGeometry.clone();
                glowMesh.scale.set(1.05, 1.05, 1.05);

                coreMesh.geometry.dispose();
                coreMesh.geometry = this.hero3D.nextGeometry.clone();
                coreMesh.scale.set(0.95, 0.95, 0.95);

                this.hero3D.morphProgress = 0;
            } else {
                // During morph: scale pulsation effect
                const scale = 1 + Math.sin(this.hero3D.morphProgress * Math.PI) * 0.3;
                mainMesh.scale.set(scale, scale, scale);
                glowMesh.scale.set(scale * 1.05, scale * 1.05, scale * 1.05);
                coreMesh.scale.set(scale * 0.95, scale * 0.95, scale * 0.95);
            }
        } else {
            // Reset scale when not morphing
            if (mainMesh.scale.x !== 1) {
                mainMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                glowMesh.scale.lerp(new THREE.Vector3(1.05, 1.05, 1.05), 0.1);
                coreMesh.scale.lerp(new THREE.Vector3(0.95, 0.95, 0.95), 0.1);
            }

            // Auto-morph timer (optional - morph automatically every X frames)
            this.hero3D.morphTimer++;
            if (this.hero3D.morphTimer > this.hero3D.morphDuration) {
                this.hero3D.morphTimer = 0;
                this.morphToNextShape();
            }
        }

        // Smooth rotation based on mouse
        const mouseInfluenceX = (this.mouse.x / window.innerWidth - 0.5) * 2;
        const mouseInfluenceY = (this.mouse.y / window.innerHeight - 0.5) * 2;

        this.hero3D.targetRotationX += mouseInfluenceY * 0.001;
        this.hero3D.targetRotationY += mouseInfluenceX * 0.001;

        // Smooth interpolation
        mainMesh.rotation.x += (this.hero3D.targetRotationX - mainMesh.rotation.x) * 0.05;
        mainMesh.rotation.y += (this.hero3D.targetRotationY - mainMesh.rotation.y) * 0.05;

        // Auto rotation
        mainMesh.rotation.x += 0.001;
        mainMesh.rotation.y += 0.002;

        // Glow and core follow main mesh
        glowMesh.rotation.x = mainMesh.rotation.x;
        glowMesh.rotation.y = mainMesh.rotation.y;
        glowMesh.rotation.z = mainMesh.rotation.z;

        coreMesh.rotation.x = mainMesh.rotation.x * 0.9;
        coreMesh.rotation.y = mainMesh.rotation.y * 0.9;
        coreMesh.rotation.z += 0.001;

        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            positions[i] += this.hero3D.particleVelocities[i];
            positions[i + 1] += this.hero3D.particleVelocities[i + 1];
            positions[i + 2] += this.hero3D.particleVelocities[i + 2];

            // Bounce particles
            if (Math.abs(positions[i]) > 50) this.hero3D.particleVelocities[i] *= -1;
            if (Math.abs(positions[i + 1]) > 50) this.hero3D.particleVelocities[i + 1] *= -1;
            if (Math.abs(positions[i + 2]) > 50) this.hero3D.particleVelocities[i + 2] *= -1;
        }
        particles.geometry.attributes.position.needsUpdate = true;

        // Rotate particles system
        particles.rotation.y += 0.0005;

        // Animate orbiting meshes
        orbitMeshes.forEach(mesh => {
            mesh.userData.angle += mesh.userData.speed;
            mesh.position.x = Math.cos(mesh.userData.angle) * mesh.userData.radius;
            mesh.position.z = Math.sin(mesh.userData.angle) * mesh.userData.radius;
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.02;
        });

        // Scroll influence
        const scrollInfluence = this.scrollY * 0.001;
        camera.position.y = scrollInfluence * 5;
        mainMesh.position.y = -scrollInfluence * 2;

        // Explosion effect
        if (this.hero3D.explosionActive) {
            this.hero3D.explosionParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                p.life -= 0.01;
            });
        }

        renderer.render(scene, camera);
    }
    
    setupScrollAnimations() {
        // Create intersection observer for section reveals
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('revealed');
                }
            });
        }, observerOptions);
        
        // Observe all sections with reveal animation
        document.querySelectorAll('.section-reveal').forEach(el => {
            observer.observe(el);
        });
        
        // Update scroll position
        window.addEventListener('scroll', () => {
            this.scrollY = window.scrollY;
            this.updateNavbar();
        });
    }
    
    setupParticleSystem() {
        const particleContainer = document.getElementById('serviceParticles');
        if (!particleContainer) return;
        
        // Create floating particles
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
            particleContainer.appendChild(particle);
        }
    }
    
    setupAboutAnimation() {
        const canvas = document.getElementById('aboutCanvas');
        if (!canvas) return;
        
        // Setup Three.js scene for about section
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
        
        renderer.setSize(canvas.width, canvas.height);
        renderer.setClearColor(0x000000, 0);
        
        // Create 3D geometry
        const geometry = new THREE.IcosahedronGeometry(2, 1);
        const material = new THREE.MeshBasicMaterial({
            color: 0x0066FF,
            wireframe: true,
            transparent: true,
            opacity: 0.8
        });
        
        const icosahedron = new THREE.Mesh(geometry, material);
        scene.add(icosahedron);
        
        // Add particle system
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 1000;
        const posArray = new Float32Array(particlesCount * 3);
        
        for (let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 20;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.005,
            color: 0x0066FF,
            transparent: true,
            opacity: 0.5
        });
        
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);
        
        camera.position.z = 8;
        
        // Animation loop
        const animateAbout = () => {
            requestAnimationFrame(animateAbout);
            
            // Rotate main geometry
            icosahedron.rotation.x += 0.01;
            icosahedron.rotation.y += 0.005;
            
            // Rotate particles
            particlesMesh.rotation.x += 0.0005;
            particlesMesh.rotation.y += 0.0003;
            
            // Mouse interaction
            icosahedron.rotation.x += this.mouse.y * 0.00005;
            icosahedron.rotation.y += this.mouse.x * 0.00005;
            
            renderer.render(scene, camera);
        };
        
        animateAbout();
        
        // Handle resize
        const handleResize = () => {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        };
        
        window.addEventListener('resize', handleResize);
        handleResize(); // Initial size
    }
    
    setupNavbar() {
        const navbar = document.getElementById('navbar');
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const mobileMenu = document.getElementById('mobileMenu');

        // Toggle mobile menu
        if (mobileMenuBtn && mobileMenu) {
            mobileMenuBtn.addEventListener('click', () => {
                mobileMenu.classList.toggle('hidden');
            });

            // Close mobile menu when clicking a link
            mobileMenu.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', () => {
                    mobileMenu.classList.add('hidden');
                });
            });
        }

        // Smooth scroll for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', (e) => {
                e.preventDefault();
                const target = document.querySelector(anchor.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    }
    
    updateNavbar() {
        const navbar = document.getElementById('navbar');
        
        if (this.scrollY > 100) {
            navbar.classList.add('scrolled');
        } else {
            navbar.classList.remove('scrolled');
        }
    }
    
    setupFormHandling() {
        const form = document.querySelector('form');
        if (!form) return;
        
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            
            // Get form data
            const formData = new FormData(form);
            const data = Object.fromEntries(formData);
            
            // Show success message
            this.showNotification('Proposta enviada com sucesso! Entraremos em contato em breve.', 'success');
            
            // Reset form
            form.reset();
        });
    }
    
    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg glass-effect glow-effect ${type === 'success' ? 'border-eterus-blue' : 'border-red-500'}`;
        notification.innerHTML = `
            <div class="flex items-center">
                <span class="mr-3">${type === 'success' ? 'âœ“' : '!'}</span>
                <span>${message}</span>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
            notification.style.opacity = '1';
        }, 100);
        
        // Remove after 5 seconds
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            notification.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 300);
        }, 5000);
    }
    
    animate() {
        // Update hero 3D animation
        if (this.hero3D) {
            this.updateHero3D();
        }

        // Continue animation loop
        requestAnimationFrame(() => this.animate());
    }
}

// Advanced hover effects for service cards
class HoverEffects {
    constructor() {
        this.serviceCards = document.querySelectorAll('.service-card');
        this.setupHoverEffects();
    }
    
    setupHoverEffects() {
        this.serviceCards.forEach(card => {
            card.addEventListener('mouseenter', (e) => {
                this.createHoverEffect(e.target);
            });
            
            card.addEventListener('mouseleave', (e) => {
                this.removeHoverEffect(e.target);
            });
            
            card.addEventListener('mousemove', (e) => {
                this.updateHoverEffect(e.target, e);
            });
        });
    }
    
    createHoverEffect(card) {
        const glow = document.createElement('div');
        glow.className = 'card-glow absolute inset-0 rounded-2xl pointer-events-none';
        glow.style.background = 'radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(0, 212, 255, 0.1) 0%, transparent 50%)';
        card.appendChild(glow);
        card.glowElement = glow;
    }
    
    removeHoverEffect(card) {
        if (card.glowElement) {
            card.removeChild(card.glowElement);
            card.glowElement = null;
        }
    }
    
    updateHoverEffect(card, e) {
        if (!card.glowElement) return;
        
        const rect = card.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        
        card.glowElement.style.setProperty('--mouse-x', x + '%');
        card.glowElement.style.setProperty('--mouse-y', y + '%');
    }
}

// Parallax effects for enhanced visual depth
class ParallaxEffects {
    constructor() {
        this.layers = document.querySelectorAll('[data-parallax]');
        this.setupParallax();
    }
    
    setupParallax() {
        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY;
            
            this.layers.forEach(layer => {
                const speed = parseFloat(layer.dataset.parallax) || 0.5;
                const yPos = -(scrollY * speed);
                layer.style.transform = `translateY(${yPos}px)`;
            });
        });
    }
}

// Typing effect for hero text
class TypewriterEffect {
    constructor(element, texts, speed = 100) {
        this.element = element;
        this.texts = texts;
        this.speed = speed;
        this.textIndex = 0;
        this.charIndex = 0;
        this.isDeleting = false;
        
        this.type();
    }
    
    type() {
        const currentText = this.texts[this.textIndex];
        
        if (this.isDeleting) {
            this.element.textContent = currentText.substring(0, this.charIndex - 1);
            this.charIndex--;
        } else {
            this.element.textContent = currentText.substring(0, this.charIndex + 1);
            this.charIndex++;
        }
        
        let typeSpeed = this.speed;
        
        if (this.isDeleting) {
            typeSpeed /= 2;
        }
        
        if (!this.isDeleting && this.charIndex === currentText.length) {
            typeSpeed = 2000;
            this.isDeleting = true;
        } else if (this.isDeleting && this.charIndex === 0) {
            this.isDeleting = false;
            this.textIndex = (this.textIndex + 1) % this.texts.length;
            typeSpeed = 500;
        }
        
        setTimeout(() => this.type(), typeSpeed);
    }
}

// Initialize everything when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Initialize splash screen
    const splash = new SplashScreen();

    // Initialize scroll progress bar
    const scrollProgress = new ScrollProgressBar();

    // Initialize advanced cursor
    const advancedCursor = new AdvancedCursor();

    // Initialize magnetic buttons
    const magneticButtons = new MagneticButtons();

    // Initialize main animations
    const animations = new EterusAnimations();

    // Initialize hover effects
    const hoverEffects = new HoverEffects();

    // Initialize parallax effects
    const parallax = new ParallaxEffects();
    
    // Add parallax data attributes to elements
    document.querySelectorAll('.animate-float').forEach(el => {
        el.setAttribute('data-parallax', '0.3');
    });
    
    // Add smooth reveal animations
    const style = document.createElement('style');
    style.textContent = `
        .card-glow {
            transition: opacity 0.3s ease;
        }
        
        .service-card:hover .card-glow {
            opacity: 1;
        }
        
        .nav-blur.scrolled {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(30px);
        }
        
        @media (max-width: 768px) {
            .process-step::before {
                display: none;
            }
        }
    `;
    document.head.appendChild(style);
    
    // Add loading animation
    window.addEventListener('load', () => {
        document.body.classList.add('loaded');
        
        // Trigger initial animations
        setTimeout(() => {
            document.querySelectorAll('.section-reveal').forEach((el, index) => {
                setTimeout(() => {
                    el.classList.add('revealed');
                }, index * 100);
            });
        }, 500);
    });
});

// Export for potential module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { EterusAnimations, HoverEffects, ParallaxEffects, TypewriterEffect };
}